# JavaScript 二进制运算

## JS运算
1. 使用 32 位二进制整数，
2. js 的整数都是有符号数
3. 最高位0表示正数
4。 1表示负数，

## 整数范围：
~~~
因此，js 二进制运算中使用的整数表达范围是 
复制代码代码如下:
~~~

```js
// -2147483648 ~ 2147483647
-Math.pow(2,31) ~ Math.pow(2,31)-1 
```
## 原码：
> 原码：最高位 0 表示正，1表示负，其余 31 位是该数的绝对值（真值的绝对值）的二进制形式 
~~~
FEI: 原码：符号位 + 该数的绝对值
~~~

## 反码：
反码：正数反码与原码相同，负数反码是原码符号位不变，其余31位取反（0变1，1变0） 
~~~
FEI的理解：
正数：反码 与 原码是相同的
负数：符号位 + （其余31位取反（0变1，1变0））
~~~

## 补码：
补码：正数补码与原码相同，负数补码为反码加 1 (符号位参与运算，其实只有求 -0 的补码才涉及最高位进位，因此不用担心在反码加1时由于符号位参与运算进位而使 - 变 +)。 

## 以 0 为例子：
+0 的反码：32个0 ，按正数处理，原码、反码、补码都是0。 
-0 的反码：最高位1，其余位由 +0 原码取反，得到 32 个 1 
-0 的补码：其反码是 32 个 1 加 1，最高位溢出被舍弃，得到 32 个0 
因此，正负 0 的补码都是 0. 
~~~
## 正0的情况：
0000 
~~~

## 我遇到的实际情况 -1>>>3 位运算：无符号右移
> >>>运算符忽略了符号位扩展，0补最高位，但是只是对32位和64位的值有意义
- https://msdn.microsoft.com/zh-cn/library/342xfs5s(v=vs.94).aspx

## 解释一下：>>> 3的步骤：
1. 原码：
1000 0000 0000 0000 0000 0000 0000 0001
2. 二进制补码为：
1111 1111 1111 1111 1111 1111 1111 1110
3. 右移3位，高位补0
000 1111 1111 1111 1111 1111 1111 1111 1
4. 对齐结果：
0001 1111 1111 1111 1111 1111 1111 1111
```js
// 29 个1
(536870911).toString(2).length
```

## 实际 case:
```js
// 补码，右移0位，得到32个1
(-1>>>0).toString(2).length
```
