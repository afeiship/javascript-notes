# 浏览器环境下js引擎的事件循环机制


## 事件循环
+ https://www.cnblogs.com/xiaohuochai/p/8527618.html

下面来详细介绍事件循环。下图中，主线程运行的时候，产生堆和栈，栈中的代码调用各种外部API，异步操作执行完成后，就在消息队列中排队。只要栈中的代码执行完毕，主线程就会去读取消息队列，依次执行那些异步任务所对应的回调函数

![](https://ws2.sinaimg.cn/large/006tNbRwly1fwrrs2sm1zj30gp0enmyn.jpg)

1. 所有同步任务都在主线程上执行，形成一个执行栈
2. 主线程之外，还存在一个"消息队列"。只要异步操作执行完成，就到消息队列中排队
3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行
4. 主线程不断重复上面的第三步

## 为什么叫事件循环？
　　为什么叫事件循环？而不叫任务循环或消息循环。究其原因是消息队列中的每条消息实际上都对应着一个事件
　　DOM操作对应的是DOM事件，资源加载操作对应的是加载事件，而定时器操作可以看做对应一个“时间到了”的事件

## WebQQ 的例子：
每一个消息完整的执行后，其它消息才会被执行。这点提供了一些优秀的特性，包括每当一个函数运行时，它就不能被抢占，并且在其他代码运行之前完全运行
这个模型的一个缺点在于当一个消息需要太长时间才能完成，Web应用无法处理用户的交互，例如点击或滚动
于是，对于这种情况的常见优化是同步变异步
一个例子是创建WebQQ的QQ好友列表。列表中通常会有成百上千个好友，如果一个好友用一个节点来表示，在页面中渲染这个列表的时候，可能要一次性往页面中创建成百上千个节点
在短时间内往页面中大量添加DOM节点显然也会让浏览器吃不消，看到的结果往往就是浏览器的卡顿甚至假死。代码如下：